# Типичные проблемы веб-разработчика и способы их решения с БЭМ

БЭМ-методология задает ряд правил по именованию CSS-селекторов, соблюдение которых решает многие насущные для веб-разработчика проблемы:

* [Как уменьшить сложность кода.](#bem-simple-code)
* [Как начать переиспользоваь код.](#bem-reuse-code)
* [Как избежать взаимного влияния компонентов друг на друга и упростить рефакторинг.](#bem-split-code)
* [Как понять, о какой конкретно сущности идет речь. Определение всех частей сущности в отрыве от контекста.](#bem-clarify-code)
* [Как улучшить скорость рендеринга.](#bem-fast)

В этой статье мы расскажем, как простые правила именования БЭМ-сущностей решают все вышеперечисленные проблемы и делают код понятным не только его автору, но и другим разработчикам.

## От проблем к решениям

Рассмотрим основные проблемы, с которыми сталкиваются веб-разработчики, и их решения с помощью соглашения по именованию в методологии БЭМ.

<a name="bem-simple-code"></a>
### Как уменьшить сложность кода в современном фронтенде

Распространенная ситуация: пока разработчик работает над проектом, он называет, казалось бы, очевидные вещи своими именами. Ему понятно, какие компоненты интерфейса для чего служат и за что отвечают.

Например, для создания простого навигационного меню могут использоваться следующие имена классов:

```html
<ul class="nav">
    <li class="item active"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

К ним будут написаны вполне понятные и прозрачные CSS-правила, например:

```css
.item
{
    padding: 4px 10px;
    color: black;
}

.active
{
    font-weight: bold;
    background: #ffc7c7;
}
```

> Проблема

Пока работа над проектом продолжается, разработчик помнит, какие компоненты могут использовать класс `active`. И если проект относится к типу «сделал-отдал-забыл», то такой вид нотации вполне приемлем. Но, если проект приходится поддерживать, то вернувшись к коду через пару месяцев, мало кому удается сразу вспомнить, на что могут повлиять правила данного селектора.

Вполне может оказаться, что на других страницах существует еще несколько вариантов использования класса `active`, например, `.link.active`.

В таком случае, чтобы разобраться, можно ли безболезненно изменить стили для `.active`, разработчику придется просмотреть всю структуру страницы или даже проекта.

А теперь представьте такую же ситуацию с большим проектом — любое изменение потребует огромных временных затрат только на поиск зависимых компонентов.

Пока разработчик справляется с тем количеством данных, которые можно удержать в голове, он можете успевать вовремя делать все необходимые изменения в коде. Но при переключении на другой проект или добавлении в существующий еще десятка страниц, такие связи становится сложно проследить.

> Решение

Методология БЭМ помогает легко отслеживать все связи между компонентами в пределах проекта при помощи соглашения по именованию CSS-классов.

Рассмотрим этот же пример, но уже с примененными правилами именования БЭМ-методологии: класс `nav` будет обозначать имя блока, `nav__item` — имя элемента, а `nav__item_active` — имя его модификатора. В таком случае запись будет следующей:

```html
<ul class="nav">
    <li class="nav__item nav__item_active"><a class="nav__link">One</a></span></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

И, соответственно, CSS будет иметь такой вид:

```css
.nav__item
{
    padding: 4px 10px;
    color: black;
}

.nav__item_active
{
    font-weight: bold;
    background: #ffc7c7;
}
```

Новые имена CSS-классов достаточно информативны, чтобы разработчику не пришлось заглядывать в HTML-код страницы. Cелектор всегда будет содержать знания о том, что данные правила влияют только на изменение конкретного блока или его элемента (в данном случае элемента `nav__item`). Разработчику не придется думать о возможном существовании `.link.active`, так как его CSS-правила будут записаны как `.link_active` и не будут зависеть от правил модификатора `active` для пункта меню.

>Такой подход имеет два потенциальных минуса:

>* Результирующий код весит больше. Эту проблему полностью решает `gzip`, который отлично сжимает повторяющиеся последовательности и сводит минус на нет.
>* Длинные имена классов писать долго. С этой проблемой помогают справиться автокомплит в редакторе и инструментарий, который автоматически добавляет префиксы (CSS-препроцессоры и шаблонизаторы).

>Основатели БЭМ-методологии считают, что затраты времени, необходимые на написание длинных имен классов, намного меньше, чем на обдумывание архитектуры.

Применение правил по именованию, предложенных БЭМ-методолгией, позволяет:

* задать четкие связи между разными сущностями;
* определить типы сущностей по их именам;
* упростить восприятие кода.

Помимо всего вышеперечисленного, использование методологии БЭМ дает возможность получить **самодокументируемый код** проекта без дополнительных усилий.

<a name="bem-clarify-code"></a>
#### Самодокументируемый код

Большинство разработчиков сталкивались с переходом на новый проект, который уже какое-то время жил своей жизнью и успел накопить тысячи строк кода, но, как чаще всего бывает, не успел обзавестись подробной документацией.

В поддержке кода важно минимизировать время, которое разработчик тратит на то, чтоб понять, как все устроено, где что лежит и как работает. Порой именно на такое изучение уходит большая часть времени, а вовсе не на реализацию функциональности или исправление ошибки.

Одна из целей БЭМ — рассказать другим разработчикам как можно больше о том, что делает тот или иной код, по названиям классов в разметке. Читая HTML с небольшим количеством классов внутри, можно увидеть взаимодействие отдельных компонентов кода; что-то может быть независимым блоком, что-то дочерним компонентом — элементом этого блока, а что-то может видоизменять блок или элемент — модификатор блока или элемента.

Используя соглашения по именованию БЭМ-сущностей, разработчик сразу способен понять всю анатомию блока, не заглядывая в HTML:

* о каком блоке идет речь, и какую часть интерфейса он реализует;
* из каких частей (элементов или других блоков) он состоит;
* каким изменениям подвергается блок благодаря тем или иным модификаторам.

Давайте рассмотрим пример с формой поиска на сайте. Не будем обращаться к HTML, попробуем прочитать только CSS и понять, какую часть интерфейса он описывает.

Для начала представим как бы такая форма могла быть реализована в классическом программировании:

```css
form {}

input
{
    bacground: red;
}

input [type=submit]
{
    background: buttonface
}
```

Такая форма записи не дает разработчику никаких сведений о взаимодействии компонентов: невозможно определить, к чему относятся данные селекторы. Использование глобальных переменных для создания правил в CSS делают код проекта нерасширяемым — при попытке рефакторинга многие правила будут поломаны.

Попытаемся немного улучшить данный код — напишем CSS на классы:

```css
.form {}
.field {}
.submit {}
```

Код стал немного информативнее, но он все еще не дает понять, относится ли поле (`field`) к форме (`form`) или что может произойти, если полей или форм на странице будет несколько.

Перепишем пример, используя БЭМ:

```css
.form {}
.form_search {}
.form__field {}
.form__submit-button {}
```

Такая запись дает полное понимание того, как работает данный код. Только из имен CSS-классов видно, что:

* Существует некий блок `form`.
* Форма здесь пердставлена уже не просто как абстрактная сущность: благодаря мофификатору `form_search` можно понять, что речь идет о форме поиска.
* У этой формы есть вложенные элементы: поле `form__field` и кнопка `form__submit-button`.

Такое именование сущностей позволяет понять структуру блока на странице без подробного изучения HTML. Даже если на странице будет еще одно поле `field`, то его правила никак не будут влиять на поле, описанное в поисковой форме, так как оно, скорее всего, будет реализовано, как элемент нового блока и будет иметь свое специфичное имя.

Жесткие правила именования в БЭМ позволяют сделать код вашего проекта прозрачным, однозначным и, как следствие, информативным. Это снижает порог входа для других разработчиков и идеально подходит для крупных проектов и больших команд. Не прилагая дополнительных усилий вы получаете самодокументируемый код.

<a name="bem-split-code"></a>
### Меняем CSS-правила одного компонента страницы и при этом не ломаем другие

Описывая страницу, зачастую оперируют одними и теми же понятиями: всевозможные пункты могут встречаться в совершенно различных ситуациях, ссылок на странице может быть множество, при этом какие-то из них должны уводить читателя на другую страницу, какие-то просто облегчать навигацию по странице.

Вернемся к примеру с навигационным меню:

```html
<ul class="nav">
    <li class="item"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

CSS-стили к пункту `item` в нем, скорее всего, будут записаны как:

```css
.item
{
    padding: 4px 10px;
    color: black;
}
```

Если на страницу понадобится добавить дополнительные компоненты, содержащие пункты, то появится еще один блок кода с классом `item`, например:

```html
<div class="snippets">
    <div class="item">
        <div class="title"></div>
        <img class="thumb">
    </div>
</div>
```

Вероятность того, что CSS-правила будут оформлены с помощью каскада возрастает, не зря ведь CSS назван Cascading Style Sheets.

```css
.item
{
    padding: 4px 10px;
    color: black;
}

.snippets.item
{
    color: red;
    font-size: 14px;
}
```

Такой подход кажется вполне удобным и логичным: необходимо просто доопределить правила, уже написанные для `item`.

> Проблема

Подобный код может совершенно безболезненно так существовать и работать до тех пор, пока не возникнет необходиомть изменить страницу, переместить какие-то пункты меню, использовать написанный код в другом месте отдельно от родителя.

Как только понадобится выполнить какое-то из вышеперечисленных действий, всплывет проблема того, что, казалось бы, независимые части кода слишком связаны и влияют друг на друга. Нет возможности исправить какой-то один компонент, не зацепив так или иначе стили другого.

Изменения стилей одного компонента страницы, могут вызвать неожиданный «сюрприз» в виде сломанного зависимого компонента в другой части проекта.

> Решение

Правила по именованию CSS-селекторов в БЭМ дают возможность вносить изменения точечно, не ломая зависимые компоненты. В БЭМ каждый компонент имеет уникальное имя и является самодостаточным.

Запишем тот же код в соответствии с правилами именования БЭМ:

```html
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

```css
.nav
{
    font-size: 12px;
}

.nav__item
{
    padding: 4px 10px;
    color: black;
}

.nav__link
{
    color: blue;
    text-decoration: underline;
}
```

В таком случае добавление нового пункта на страницу ничего не сломает — у пункта `snippets` появится свое специфичное имя `snippets__item`.

```html
<div class="snippets">
    <div class="snippets__item">
        <div class="snippets__title"></div>
        <img class="snippents__thumb" />
    </div>
</div>
```

Пункт `snippets__item` будет иметь соответсвующие только ему уникальные CSS-правила. Например:

```css
.snippets__item
{
    padding: 4px 10px;
    color: red;
    font-size: 14px;
}
```

Внесенные изменения в `nav__item` никак не отобразятся на пункте `snippets__item`.

Прозрачное именование блоков, элементов и модификаторов и уход от каскадов позволят вносить изменения только в конкретные компоненты и иметь четкое представление, к какому блоку относится каждый элемент и какие стили могут на него влиять.

Таким образом, элемент `item` получает уникальные независимые CSS-стили благодаря неймспейсам в виде имен блоков. Такой подход дает возможность защитить элементы от взаимного влияния друг на друга — элементы всегда располагаются внутри блока. Такой же принцип работы использует и Shadow Dom в Web Components. Но, в отличие от Shadow Dom, применение БЭМ-нотации не зависит от поддержки браузеров и конкретного API.

Блоки `snippets` и `nav` можно повторно использовать на других страницах или в другом проекте. Уникальность имен классов, основанная на правилах именования БЭМ, позволяет блокам не зависеть друг от друга.

Независимость блоков касается не только CSS. В методологии БЭМ блок является абсолютно самодостаточной единицей. Он знает о себе все: свой внешний вид (CSS), поведение (JavaScript) и шаблоны и перечень блоков, с которыми ему необходимо взаимодействовать (зависимости).

// сослаться на док «Зачем БЭМ в JavaScript»


#### Использование каскадов в БЭМ

Из предыдущей главы может сложиться впечатление, что методология БЭМ полностью отрицает каскады в CSS. Это не совсем так — каскады в БЭМ существуют, но встречаются значительно реже.

Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока (`.nav_hovered .nav__link { text-decoration: underline; }`) или, скажем, темы (`.nav_theme_islands .nav__item { line-height: 1.5; }`).

В случае использования каскада повышается вероятность связанности кода, что делает его повторное использование невозможным и увеличивает риски попасть в ситуацию, когда переписать проще, чем исправить.

### Миксы или как разместить несколько сущностей на одном DOM-узле

Воспользуемся еще раз нашим примером, который реализует универсальный блок навигационного меню. Такой блок можно использовать в совершенно различных случаях.

```
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

Может возникнуть необходимость применить его в составе нового блока. Допустим, отображать с его помощью какие-то статьи в блоке новостей. В таком случае воздействовть на блок `nav` с помощью модификаторов — не самый хороший выбор, так как семантически `nav` будет уже принципиально другим блоком — блоком новостей.

Решить такую задачу можно при помощи [микса]() двух блоков. То есть смешать на одном DOM-узле два разных блока: блок `nav` и `articles`. Блок `articles`, предположим, будет отвечать за внешний вид новостных статей в меню.

```html
<ul class="nav articles">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

При этом такая реализация будет содержать всю функциаональность блока `nav`, а также особенности реализации блока `articles`.

>Точно также можно смешивать блоки с элементами [и не только](ссылка на difinitions в раздел).

Снова вернемся к нашему примеру. В нем используется ссылка в качестве элемента блока `nav` — `nav__link`. Но в проекте ссылка вполне может быть и отдельным блоком.

Например, в проекте все ссылки изначально должны быть реализованы одинаково. Для этого создается блок `link` и его CSS-правила `.link { color: blue }`. Но может возникнуть необходимость сделать ссылки в навигационном меню шапки немного больше и заметнее.

В такой ситуации также удобно воспользоваться миксом — в этот раз смешать на одном DOM-узле блок и элемент другого блока. В нашем случае это будет блок `link` и элемент `nav__link`.

Нет смысла создавать еще один блок, можно просто добавить специфические правила для ссылки, актуальные только навигационному меню, расположенному в шапке:

```
.nav__link
{
   font-size: 14px;
   font-weight: bold;
}
```

Для того, чтобы стили `nav__link` применились к ссылкам в меню, нужно просто подмешать к блоку `link` элемент `nav__link`.

Пример вполне может выглядеть так:

```html
<ul class="nav">
    <li class="nav__item">
        <a class="link nav__link"></a>
    </li>
</ul>
```

При этом все общее, что есть у всех ссылок в проекте, будет описано в блоке `link`, а особенности, присущие только ссылке внутри `nav`, в `nav__link`.

<a href="bem-fast"></a>
### Скорость рендеринга и селекторы большой вложенности в CSS

Как уже говорилось выше применение каскада в CSS вполне оправдано в случае стандартного подхода к разработке, но использование селекторов большой вложенности может повлиять на быстродействие сайта.

Большинство браузеров начинают применять селектор с «правой части» (охватывающей чаще всего большее множество узлов) и затем уточняют полученную выборку, фильтруя ее применением оставшихся правил. Чем больше шагов фильтрации требуется, тем больше времени это занимает.

Правила именования в БЭМ созданы таким образом, что каждый БЭМ-класс имеет уникальное имя и является самодостаточным – разные блоки никогда не пересекаются по именам классов.

Это означает, что в большинстве случаев достаточно указать один класс, чтобы:

* описать стили самого блока;
* описать стили любого элемента внутри блока;
* добавить дополнительные стили или переопределения с помощью модификатора.

Селекторы, состоящие из одного класса, как минимум относятся к самым быстрым селекторам из всех возможных.

